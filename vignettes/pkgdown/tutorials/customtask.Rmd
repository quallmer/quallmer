---
title: "Defining custom tasks"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this tutorial, we will explore how to create custom annotation tasks using the `quallmer` package. Custom tasks allow you to tailor the LLM's output to your specific research questions and data types using the `qlm_codebook()` function, providing greater flexibility and control over the annotation process.

In the following example, we will demonstrate how to define a custom codebook for scoring documents
based on their alignment with political left ideologies. For this, we formulate instructions that ask the LLM to score documents on a scale of political left alignment. We then define the expected response structure using the `qlm_codebook()` function. Finally, we will use the `qlm_code()` function to apply this custom codebook to a sample corpus of inaugural speeches from US presidents.

### Loading packages and data

```{r getting-started}
# We will use the quanteda package 
# for loading a sample corpus of innaugural speeches
# If you have not yet installed the quanteda package, you can do so by:
# install.packages("quanteda")
library(quanteda)
library(quallmer)

# For educational purposes, 
# we will use a subset of the inaugural speeches corpus
# The three most recent speeches in the corpus
data_corpus_inaugural <- quanteda::data_corpus_inaugural[57:60]

```

### Defining custom instructions

Defining instructions is a crucial step in creating custom codebooks. The instructions guide the LLM on how to interpret the input data and what kind of output to generate. In this example, we will create instructions that tell the LLM to score documents based on their alignment with political left ideologies. Instructions can be much longer and more complex depending on the task at hand. Instructions should be clear and specific to ensure that the LLM understands the task requirements.

```{r define-instructions}

instructions <- "Score the following document on a scale of how much it aligns
with the political left. The political left is defined as groups which
advocate for social equality, government intervention in the economy,
and progressive policies. Use the following metrics:
SCORING METRIC:
3 : extremely left
2 : very left
1 : slightly left
0 : not at all left"

```

### Defining the codebook with qlm_codebook()

The `qlm_codebook()` function allows us to specify the expected structure of the LLM's response. It has the following important arguments which users need to specify:

- `name`: A descriptive name for the codebook.
- `instructions`: The instructions that guide the LLM on how to perform the coding task.
- `schema`: Defines the expected structure of the response using [ellmer's type specifications](https://ellmer.tidyverse.org/reference/type_boolean.html) such as `type_object()`, `type_array()`, etc.
- `role`: (Optional) A role description for the model (e.g., "You are an expert political scientist").
- `input_type`: The type of input data (`"text"` or `"image"`).

For more information on how to use ellmer's type specifications, please refer to the [ellmer documentation on type specifications](https://ellmer.tidyverse.org/reference/type_boolean.html).

```{r define-codebook}
# Define the custom codebook using qlm_codebook()
ideology_codebook <- qlm_codebook(
  name = "Score Political Left Alignment",
  instructions = instructions,
  schema = type_object(
    score = type_number("Score"),
    explanation = type_string("Explanation")
  ),
  role = "You are an expert political scientist analyzing political texts.",
  input_type = "text"
)
```

### Applying the custom codebook to the corpus

We use the `qlm_code()` function to apply our custom codebook to the sample corpus of inaugural speeches. We specify the model to use via `model` (in this case, `"openai/gpt-4o"`) and any additional parameters as needed. For example, we set the temperature to 0 for more deterministic outputs, improving consistency in scoring across multiple runs and therefore increasing reliability.

The `qlm_code()` function returns a rich `qlm_coded` object that contains the results along with metadata about the coding process. To extract just the results as a data frame, we use the `qlm_results()` function.

```{r apply-codebook}
# Apply the custom codebook to the inaugural speeches corpus
coded <- qlm_code(data_corpus_inaugural,
                  codebook = ideology_codebook,
                  model = "openai/gpt-4o",
                  temperature = 0)

# Extract the results as a data frame
result <- qlm_results(coded)
```

```{r display_results, echo = FALSE}
# Display the ideology scoring results
library(kableExtra)
result %>%
  kable("html", escape = FALSE) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  column_spec(3)
```

Now you have successfully created and applied a custom annotation codebook using the `quallmer` package! You can further modify the instructions, role, and response structure to suit your specific research needs.
